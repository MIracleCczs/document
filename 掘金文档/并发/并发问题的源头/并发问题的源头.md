> 在[java基础-String、StringBuiler和StringBuffer](https://juejin.cn/post/6985421045033336845)中提到了线程安全的问题，那今天就来聊聊并发问题的源头。

### 线程切换带来的原子性问题
>一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

一个很经典的例子就是银行账户转账问题： 

比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。这2个操作必须要具备原子性才能保证不出现一些意外的问题。

我们操作数据也是如此，比如i = i+1；其中就包括，读取i的值，计算i，写入i。这行代码在Java中是不具备原子性的。

![原子性](F:\miracle\java going\并发\原子性.png)


### CPU缓存导致的可见性问题
> 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

若两个线程在不同的cpu，线程A和线程B同时执行，会从主内存中加载共享变量V缓存到本地内存中。线程A修改了共享变量V还没有写到主存中，线程B也修改了变量V，两线程之间互不可见。那么当它们向主存中刷新变量V的值时，一定有一个线程会覆盖另外一个线程的结果。这就是可见性问题。

![可见性](F:\miracle\java going\并发\可见性.png)

### 编译优化带来的有序性问题
>程序执行的顺序按照代码的先后顺序执行。

一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。如下：
```java
int a = 10;    //语句1
int r = 2;    //语句2
a = a + 3;    //语句3
r = a*a;     //语句4 
```
则因为重排序，他还可能执行顺序为 2-1-3-4，1-3-2-4，但绝不可能 2-1-4-3，因为这打破了依赖关系。显然重排序对单线程运行是不会有任何问题，而多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。
例：

```java
    int a = 0;
    boolean flag = false;

    public void write() {
        a = 1;  //1
        flag = true; //2
    }

    public void read() {
        if (flag) { // 3
            int b = a * a; //4
        }
    }
```
>上面的代码中，线程A执行write()，线程B执行read(),如果发生指令重排先执行了flag=true,此时线程切换到B去执行，执行结果就是错的了。

### 双重校验锁机制的线程安全



### 总结

原子性、可见性和有序性都会导致并发问题，所有并发问题的处理也都是围绕这三个特性的。