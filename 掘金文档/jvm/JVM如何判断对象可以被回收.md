Java堆中几乎存放这所有的对象实例，对Java堆得垃圾回收前的第一步就是判断对象已经死亡，即不能再被任何途径使用的对象。

### 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题**。所谓对象之间的相互引用问题，如下面代码所示：除了对象objA和objB相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知GC回收器回收他们。

```java
public class CircleReference {

    Object instance = null;

    public static void main(String[] args) {
        CircleReference objA = new CircleReference();
        CircleReference objB = new CircleReference();
        
        objA.instance = objB;
        objB.instance = objA;
    }
}

```

### 可达性分析算法

通过GC Roots根对象根据引用关系向下搜索，如果某个对象到GC Roots没有任何引用链，证明此对象不可能再被使用。GC Roots包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、Native方法引用的对象、虚拟机内部的引用、被同步锁持有的对象等。

![可达性分析算法](/Users/miracle/miracle/githubdoc/document/掘金文档/jvm/可达性分析算法.png)

### 常见引用类型

java的引用类型一般分为四种：强引用、软引用、弱引用、虚引用。

**强引用：普通的变量引用**，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

```java
Object o = new Object();
```

**软引用**：只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。

```java
SoftReference<Object> softReference = new SoftReference<>(new Object());
```

**弱引用**：被弱引用关联的对象只能生存到下次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

```java
WeakReference<Object> weakReference = new WeakReference<>(new Object());
```

**虚引用**：虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存空间构成影响，也无法通过需引用来取得一个对象实例。为一个对象设置需引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个通知。

```java
PhantomReference<Object> phantomReference = new PhantomReference<>(new Object(), new ReferenceQueue<>());
```

### finalize()方法最终判定对象是否存活

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。**标记的前提是对象在进行可达性分析后发现没有与GCRoots相连接的引用链。**

1. 第一次标记并进行一次筛选。筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize方法，对象将直接被回收。

2. 第二次标记如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。

### 方法区内存回收

方法区垃圾收集判定条件苛刻，垃圾收集效果远低于Java堆。但是在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP和OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。主要回收两部分内容：废弃的常量和不再使用的类型。

类需要满足下面3个条件才能算作是无用的类：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

